# 상태 관리 라이브러리
- 모던 리액트 p.337
## 상태란?
- UI: radio, checkbox, input, light, dark 등
- URL: 도메인이나 라우트, QueryString 등이 있다
- 폼: Loading, Submitted, Disabled, Valiation 등
- 서버: 요청으로 서버에서 가져온 값을 상태로 판단할 수 있다. 대표적으로 API 요청이 있다.
### 상태 관리는 왜 해야하는가?
- 상태 자체를 관리하는 것은 어려운 문제가 아니고, 단순히 번거로운 일일 뿐이다.
- 다만 전체적으로 관리해야하는 상태가 있다고 가정한다면, 다양한 문제가 발생한다. 상태를 어디에 두어야 하는가? 전역 변수 또는 클로저? 상태가 유효한 범위를 제한하는 것은? 상태의 변화에 따라 변경되어야하는 자식 요소는 이 변화를 어떻게 감지하는가?
- 상태변화가 일어남에 따라 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상을 Tearing이라고 하며, 하나의 상태에 따라 서로 다른 결과물을 보여주는 현상을 의미한다.
### Prop Drilling은 전역 상태관리를 위한 옵션이 될 수 있을까?
- Prop Drilling 해결을 위해 전역 상태 관리를 사용한다는 것은 자칫 잘못하면 전역 상태관리의 남용을 유발할 수 있다.
- 전역 상태는 달리 말하면 전역변수와 같다. 프로그래머에게 있어 가장 금기시되는 것이 바로 전역변수의 남용이다. 반드시 코드의 가독성을 떨어뜨리며 스파게티 코드를 만들 가능성이 높아지기 때문이다.
- 즉 전역 상태는 유지보수를 개발보다 중요하게 생각하는 개발자라면 지극히 제한적으로 사용해야만 한다.
- 애초에 Prop Drilling은 다양한 방법으로 회피할 수 있다. 블록 단위로 사용이 가능한 useContext와 Render Props가 있다. 또한 완벽한 대안은 아니지만 합성 컴포넌트 역시 사용 가능한 옵션 중 하나다.
## Recoil
### RecoilRoot의 특징
- Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
- 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
- 값이 변경되면 이를 참조하고 있는 하위 컴포넌트들에게 모두 알린다.
### Recoil을 왜 써야하는가?
- Redux에 비해 러닝커브가 적고, 코드가 직관적이며 보일러플레이트도 적다.
- React의 개발사인 메타가 개발하는 라이브러리이다.
## React hooks
- useReducer + useState를 기반으로 전역 상태관리
- useState + useContext를 기반으로 전역 상태관리
    - 다만 이 경우 하위 컴포넌트의 리렌더링은 불가피하다
- useSubscription = useReducer + useState와 형태는 유사하나 안정성 있게 관리 가능 v18부터 사용 가능하다
  - 이건 10장에서 다시 다룬다고 함
# useDefferValue
- useDefferValue는 상태 변화를 가장 마지막으로 연기하는 hooks다. 예를 들어 state1~state10까지 상태가 있는 경우, state2를 감쌌다 가정해보자. 순차적으로 상태가 변경된다면 state2는 2번째변경된다. 다만 useDefferValue로 감싸진 defferState2는 가장 마지막에 호출된다.
## usage
```ts
export default function useDeffer() {
	const [value, setValue] = useState(0);
	const defferedValue = useDefferValue(value);
}
```
- 이 연기된 값은 어떻게 쓸 수 있을까? 코드를 올릴 수는 없지만, 현재 회사 프로젝트에서 이 hooks를 통해 문제를 해결한 케이스가 있어서 공유한다.
- 그 프로젝트엔 api를 통해 컨텐츠를 읽어서 그 컨텐츠의 특정 페이지를 입력하면 그 페이지로 자동으로 스크롤 되는 컴포넌트가 있다. 여기서 발견된 버그는 컨텐츠의 크기가 충분히 커서 사용자가 입력할 시간이 존재할 때(즉 컨텐츠가 완전히 load되지 않았을 때) 해당 컨텐츠의 scrollTop을 읽으려해서 런타임 에러가 발생했다.
- 그래서 해결한 방법은 먼저 defferedValue를 통해 해당 값이 변경되기 전엔 페이지 이동을 금지시키는 것이었다.